# 비관적 락

**비관적 락(Pessimistic Lock)**은
👉 *“다른 트랜잭션이 이 데이터를 건드리면 문제 날 것 같으니, 아예 먼저 잠가버리자”*라는 동시성 제어 방식이다.

---

## 1. 비관적 락이 뭔가?

DB 레벨에서 **데이터를 조회하는 순간부터 잠금(Lock)을 거는 방식**이다.

* 한 트랜잭션이 데이터를 읽거나 수정하려고 하면
* **다른 트랜잭션은 해당 데이터에 접근 자체가 차단**된다
* 첫 트랜잭션이 끝나야(lock 해제) 다음 트랜잭션이 접근 가능

즉, **충돌이 날 거라고 “비관적으로” 가정**하는 방식이다.

---

## 2. JPA에서의 비관적 락

JPA에서는 보통 이렇게 쓴다:

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
Optional<Wallet> findById(Long id);
```

이건 내부적으로 DB에 이런 SQL을 날린다:

```sql
SELECT * FROM wallet WHERE id = ? FOR UPDATE;
```

의미:

* 이 row는 **내 트랜잭션이 끝날 때까지**
* 다른 트랜잭션이 **읽기/쓰기 못 함**

---

## 3. 왜 쓰는가?

### ✅ 이런 상황에서 필요

* **돈, 포인트, 재고**
* 동시에 수정되면 절대 안 되는 데이터
* “나중에 충돌 나면 롤백”이 아니라
  **애초에 충돌을 막고 싶을 때**

예:

* 두 요청이 동시에 잔액을 차감
* 결과적으로 돈이 음수가 되거나 꼬이는 문제

---

## 4. OneToOne에서 문제가 되는 이유 (핵심)

> OneToOne은 쓰기 충돌 제어에 부적합하다

### 이유 1️⃣

`@OneToOne`은 보통

* **양쪽 중 한쪽이 FK + UNIQUE 제약**
* row 수가 1:1로 강하게 묶임

이 구조에서는:

* **락의 대상이 명확하지 않거나**
* **FK/UNIQUE 충돌이 먼저 터지는 경우**가 많다

### 이유 2️⃣

실제 락은 **테이블 row 단위**로 걸리는데
OneToOne은 “관계”는 1:1이지
**락 단위 자체를 안전하게 분리하기 어렵다**

---

## 5. 그래서 `ManyToOne`으로 바꾼 이유

```java
@ManyToOne(fetch = FetchType.LAZY)
private CashMember holder;
```

이렇게 하면:

* Wallet은 **독립적인 row**
* holder는 **참조만 하는 구조**
* Wallet row에 대해:

  ```sql
  SELECT ... FROM wallet WHERE id = ? FOR UPDATE;
  ```

  → **명확하게 락 가능**

즉,

> 💡 **락을 걸 대상(지갑)을 확실히 분리**하기 위한 설계

---

## 6. 한 줄 요약

* **비관적 락**: “문제 생길 것 같으니 먼저 잠근다”
* **DB row를 트랜잭션 동안 독점**
* **돈/포인트 같은 데이터에 필수**
* OneToOne은 락 설계가 불안정
* **ManyToOne + 독립 엔티티**가 비관적 락에 안전